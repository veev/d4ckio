<!DOCTYPE html>
<html>
  <head>
		<meta content="width=device-width, initial-scale=1" name="viewport" />
    <link href="https://fonts.googleapis.com/css?family=Source+Serif+Pro:400,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700&display=swap" rel="stylesheet">
    <style>
      body {
        margin: 0;
        background-color:#FF254A;
      }
			.container { 
				border: 0;
				height: 100%;
				left: 0;
				position: absolute;
				top: 0;
				width: 100%;
				overflow: hidden;
			}
			.headerNav {
				/* min-height: 20vh; */
				height: 20%;
				margin: 20px auto 0px;
        width: 58%;
				display: flex;
				flex-direction: row;
				justify-content: center;
				align-items: center;
			}
			.navArrow {
				/* width: 50px; */
				/* height: 50px; */
				/* background-color: white; */
				/* padding-top: 15px; */
				cursor: pointer;
			}
			i:hover {
				color: white;
			}
			.navArrow[disabled]{
				pointer-events: none;
				opacity: 0.7;
			}
			#leftArrow {
				padding-right: 5px;
			}
			#rightArrow {
				padding-left: 5px;
			}

			i {
				border: solid black;
				border-width: 0 2px 2px 0;
				display: inline-block;
				padding: 15px;
			}

			.right {
				transform: rotate(-45deg);
				-webkit-transform: rotate(-45deg);
			}

			.left {
				transform: rotate(135deg);
				-webkit-transform: rotate(135deg);
			}
			#callout {
				position: relative;
				display: block;
				font-family: 'Source Serif Pro', serif;
				font-size: 1.6rem;
				text-align: center;
			}
      #callout > .highlight {
        color: white;
      }
			.menu {
				position: relative;
				text-align:center;
  			align-content:center;
			}
			.legend {
				display: flex;
				flex-direction: row;
				height: 20px;
				justify-content: center;
				padding-bottom: 20px;
				font-family:'Source Sans Pro', sans-serif;
				font-size:12px;
			}
			.legendLabel {
				padding-left: 5px;
				padding-right: 10px;
			}
			.legendTitle {
				text-transform: uppercase;
				font-weight: 800;
				margin-right: 10px;
			}
			.legendCircle {
				border-radius: 50%;
				margin: 2px 0px 0px 0px;
				width: 12px;
				height: 12px;
			}
			#nationalCircle {
				background-color: #bf1b32;
			}
			#regionalCircle {
				background-color: #ff7a91;
			}
			#localCircle {
				background-color: white;
			}
			#unknownCircle {
				border:1px solid white;
				width: 12px;
				height: 12px;
				background-color: #FF254A;
			}
			.buttonGroup {
				margin:0 auto;
   			display:block;
			}
			.button {
				background-color:white;
				border-radius:25px;
				border-width: 0px;
				display:inline-block;
				cursor:pointer;
				color:black;
				font-family:'Source Sans Pro', sans-serif;
				font-size:12px;
				padding:5px 12px;
				margin: 1px 1px 5px 1px;
				text-decoration:none;
			}
			.button:hover {
				background-color:#7d7d7d;
				color: white;
			}
			.button:active {
				background-color:black;
				color: white;
				position:relative;
				top:1px;
			}
			.button:focus {
				background-color: black;
				color: white;
    		outline: none; 
			}
			.button.selected {
				background-color:black;
				color: white;
				outline: none;
			}
			#svgCanvas {
				position: relative;
				height: 65%;
				margin-bottom: 15px;
			}
      svg {
        margin: 0 auto;
        display: table;
      }
      .ancestor-circle {
        fill-opacity: .1;
        stroke-width: 2px;
      }
      .leaf-circle {
        fill-opacity: 1;
        stroke-width: 1.5px;
      }
			.group-label {
				font-family:'Source Sans Pro', sans-serif;
				font-size:14px;
			}
			div.tooltip {
				color: black;
				position: relative;
				text-align: left;
				/* width: 120px; */
				/* height: 28px; */
				padding: 8px;
				font: 10px 'Source Sans Pro', sans-serif;
				background: rgba(255,255,255,1);
				box-shadow: 0 0 10px gray;
				pointer-events: none;
			}
			div.tooltip:after, div.tooltip:before {
				right: 100%;
				top: 50%;
				border: solid transparent;
				content: " ";
				height: 0;
				width: 0;
				position: absolute;
				pointer-events: none;
			}

			div.tooltip:after {
				border-color: rgba(255, 255, 255, 0);
				border-right-color: #ffffff;
				border-width: 10px;
				margin-top: -10px;
			}
			div.tooltip:before {
				border-color: rgba(194, 194, 194, 0);
				border-right-color: #c2c2c2;
				border-width: 11px;
				margin-top: -11px;
			}
			@media screen and (max-width: 375px) {
				.headerNav {
					height: 25%;
					margin: 20px auto 0px;
					width: 90%;
				}
				#callout {
					font-size: 1.2rem;
				}
				#svgCanvas {
					height: 48%;
					margin-bottom: 15px;
				}
				.group-label{
					font-size: 9px;
				}
				.legend {
					font-size: 10px;
				}
				.legendCircle {
					border-radius: 50%;
					margin: 2px 0px 0px 0px;
					width: 9px;
					height: 9px;
				}
				#unknownCircle {
					width: 9px;
					height: 9px;
				}
			}

			@media screen and (min-width: 375px) and (max-width: 600px) {
				.headerNav {
					height: 25%;
					margin: 20px auto 0px;
					width: 90%;
				}
				#callout {
					font-size: 1.3rem;
				}
				#svgCanvas {
					height: 48%;
					margin-bottom: 15px;
				}
				.group-label{
					font-size: 12px;
				}
			}	
			@media screen and (min-width: 768px) and (max-width: 1024px) and (orientation: portrait) {
				.headerNav {
					height: 20%;
    			margin: 20px auto 0px;
    			width: 84%;
				}
				i {
						padding: 25px;
				}
				#callout {
					font-size: 2.2rem;
				}
				#svgCanvas {
					height: 55%;
					margin-bottom: 15px;
				}
				.group-label{
					font-size: 18px;
				}
				.legend {
					height: 20px;
					padding-bottom: 46px;
					font-size: 24px;
				}
				.buttonGroup {
					margin: 0 auto;
    			width: 85%;
    			display: block;
				}
				.button {
					border-radius: 30px;
    			font-size: 25px;
    			padding: 12px 24px;
    			margin: 6px 1px 5px 1px;
				}
				.legendCircle {
					margin: 6px 0px 0px 0px;
    			width: 20px;
    			height: 20px;
				}
				#unknownCircle {
					width: 20px;
					height: 20px;
				}
			}	
    </style>
  </head>
  <body>
			<div class="container">
				<div class="headerNav">
					<div id="leftArrow" class="navArrow"><i class="left"></i></div>
					<div id="callout" ></div>
					<div id="rightArrow" class="navArrow"><i class="right"></i></div>
			</div>
      <div id="svgCanvas"></div>
			<div class="menu">
				<div class="legend">
					<div class="legendTitle">Shutdown Scope</div>
					<div id="nationalCircle" class="legendCircle"></div>
					<div class="legendLabel">National</div>
					<div id="regionalCircle" class="legendCircle"></div>
					<div class="legendLabel">Regional</div>
					<div id="localCircle" class="legendCircle"></div>
					<div class="legendLabel">Local</div>
					<div id="unknownCircle" class="legendCircle"></div>
					<div class="legendLabel">Unknown</div>
				</div>
				<div class="buttonGroup">
					<button id="all" class="button active">All</button>
					<button id="sub_region" class="button">Regions</button>
					<button id="actual_cause" class="button">Cause</button>
					<button id="ordered_by" class="button">Ordered By</button>
					<button id="official_just" class="button">Justification</button>
					<button id="shutdown_type_new" class="button">Shutdown Type</button>
					<button id="affected_network" class="button">Affected Network</button>
				</div>
			</div>
		</div>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
			const calloutMap = {
				// "all": {
				// 	"main": "In 2019, 1707 days of internet access were disrupted by 214 internet shutdowns across 33 countries.",
				// 	"totalDays": 1707,
				// 	"numShutdowns": 214,
				// 	"numCountries": 33
				// 	},
				"all": 'In 2019, <span class="highlight">1707</span> days of internet access were disrupted by <span class="highlight">214</span> internet shutdowns across <span class="highlight">33</span> countries.',
				"sub_region": 'The subregion most affected by internet shutdowns is <span class="highlight">Southern Asia</span>. In 2019, <span class="highlight">122</span> shutdowns were recorded in <span class="highlight">India</span>.',
				"actual_cause": '<span class="highlight">Protests</span> are the top known cause of internet and network shutdowns.',
				"ordered_by": 'From central governments to local administrations, many have the power to order an internet shutdown.',
				"official_just": 'Public safety, national security, or stopping fake news are commonly used to justify shutdowns designed to prevent protests.',
				"shutdown_type_new": 'Speed throttling is more subtle than a full network shutdown and is more likely to go undetected.',
				"affected_network": '<span class="highlight">62%</span> of the shutdowns recorded by STOP in 2019 affected both broadband and mobile networks.'
			}

			const selectedButtonIds = ["all", "sub_region", "actual_cause", "ordered_by", "official_just", "shutdown_type_new", "affected_network"]
			let selectedIndex = 0
			const lineHeight = 12

			const margin = {
				left: 0, 
				right: 0, 
				top: 0, 
				bottom: 0
				},
        duration = 1000,
				radius = 6;
					
      let buttonId = 'all'

      const svg = d3.select("#svgCanvas").append("svg");
      const g = svg.append("g");
			const lg = svg.append("g")
			
      const pack = d3.pack()
          .padding(d => d.padding || 0);

			// add tooltip
			const div = d3.select('body').append('div').attr('class', 'tooltip').attr('style', 'position: absolute; opacity: 0;');

    d3.csv('data/Data4Gen-Data4Viz.csv').then( data => {
        console.log(data)

        const formatted = getFormattedData(data, radius)
        console.log(formatted)

        // let randomRoot = d3.hierarchy(makeData())
        //             .sum(d => d.value)
        //             .sort((a, b) => a.value - b.value);
        
        let root = d3.hierarchy(updateNodeGroups(formatted, buttonId))
            .sum(d => d.radius)
						.sort((a,b) => a.data.geo_scope_val - b.data.geo_scope_val)
						// .sort((a,b) => a.geo_scope_val - b.geo_scope_val)
    
        // console.log(root)

        draw(false, root, buttonId);

        onresize = _ => draw(true, root, buttonId);

        function getFormattedData(data, radius) {
            const mapped = data.map( d => {
                // create new leaner obj
                // set radius based on geo_scope
                if (d.geo_scope === 'Unknown') {
                    // d.radius = radius * 1
										d.geo_scope_val = 0
										d.geo_scope_label = 'Unknown'
                } else if (d.geo_scope === 'Level 1') {
                    // d.radius = radius * 1
										d.geo_scope_val = 1
										d.geo_scope_label = 'Local'
                } else if (d.geo_scope === 'Level 2') {
                    // d.radius = radius * 3
										d.geo_scope_val = 2
										d.geo_scope_label = 'Regional'
                } else if (d.geo_scope === 'Level 3') {
                    // d.radius = radius * 4
										d.geo_scope_val = 3
										d.geo_scope_label = 'National'
                }
								if (d.official_just === 'Fake News / Hate Speech / Incendiary Content or Promoting Violence') {
									d.official_just = 'Hate Speech / Information Control'
								} else if (d.official_just === 'Public Safety / Quell Unrest / Restore Public Order') {
									d.official_just = 'Public Safety and Order'
								} else if (d.official_just === 'National Security / Counter-Terrorism') {
									d.official_just = 'National Security'
								} else if (d.official_just === 'Sabotage / Third-party Action') {
									d.official_just = 'Third-party Action'
								} else if (d.official_just === 'Technical Problems / Infrastructure Failure') {
									d.official_just = 'Technical Problems'
								} else {
									d.official_just = d.official_just
								}
								if (d.actual_cause === 'Religious holiday/anniversary') {
									d.actual_cause = 'Religious Holiday'
								} else if (d.actual_cause === 'Visits by Government Officials') {
									d.actual_cause = 'Visits by Officials'
								}
                d.access_now_ID = +d.access_now_ID
                d.duration_affected_days = +d.duration_affected_days
								d.radius = radius
                // set starting position in center of svg
                // d.focusX = width / 2
                // d.focusY = height / 2
                // console.log(width, height, d.focusX, d.focusY)
                d.start_date_obj = new Date(d.start_date)
                return d
                // sort (not doing anything atm)
            })
            const sorted = mapped.sort((a, b) => new Date(b.start_date) - new Date(a.start_date)).reverse()
            //   console.log(sorted)
            return sorted
        }

        function draw(resizing, myRoot, myButtonId) {

						// get the dom element width
						function getDivDimension (div, dim) {
							// console.log(div, dim)
							const dimension = d3.select(div)
								// get the width of div element
								.style(dim)
								// take off 'px'
								.slice(0, -2)
							// return as an integer
							return Math.round(Number(dimension))
						}

						const width = getDivDimension("#svgCanvas", "width")
						const height = getDivDimension("#svgCanvas", "height")

            svg
							.attr("width", width + margin.left + margin.right)
							.attr("height", height + margin.top + margin.bottom);

            g
							.attr("transform", `translate(${margin.left}, ${margin.top})`);

						lg
							.attr("transform", `translate(${margin.left}, ${margin.top})`);

            pack
							// .radius(myRoot, d => )
							.size([width, height])
							.padding(d => {
								// console.log(d)
								return d.data.padding;
							})
							// pack.radius(d => {
							// 	console.log(d)
							// 	return d.value
							// }); 

            let node = pack(myRoot);
						let leaves = node.leaves();
						let	ancestors = node.ancestors();

						console.log('root', myRoot)

            console.log(leaves)
            console.log(node.ancestors()[0].children)

						const t = d3.transition()
        			.duration(1000)

						// try sorting leaves based on x and y values
						const newLeaves = [...leaves].sort((a,b) => {
							//sort by x, secondary by y
  						return a.x == b.x ? a.y - b.y : a.x - b.x;
						})

						console.log(leaves)
						console.log(newLeaves)

						let leafCounter = 0
						// const mappedNewLeaves = leaves.map( l => {
						// 	l.x = newLeaves[leafCounter].x
						// 	leafCounter++
						// 	return l
						// })
						// console.log(mappedNewLeaves)
						
						// const t500 = d3.transition().duration(500)
						// const t2000 = d3.transition().duration(2000)
						// console.log('t', t)
						
						const ancestorCircles = g.selectAll(".ancestor-circle")
							.data(node.ancestors()[0].children, d => d.data.name)
							.join(
								enter => enter.append("circle")
									.style("fill", "white")
									.style("stroke","white")
									.attr("class", "ancestor-circle")
									.attr("stroke-opacity", 0.4 )
									.attr("cx", d => d.x)
									.attr("cy", d => d.y)
									.attr("r", d => d.r)
									.attr("opacity", 0)
								.call(enter => enter.transition(t)
								.attr("opacity", 1)	
								),
								update => update
									.attr("cx", d => d.x)
									.attr("cy", d => d.y)
									.attr("r", d => d.r)
								.call(update => update.transition(t)
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y)
                    .attr("r", d => d.r)
								),
								exit => exit
									.call(exit => exit.transition(t/2)
										.attr("r", 1e-6)
                    .remove()
									)
							)
			
						const leafCircles = g.selectAll(".leaf-circle")
							.data(
								node.leaves(), d => d.data.access_now_ID)
							// node.leaves().map( l => {
							// 	l.x = newLeaves[leafCounter].x
							// 	l.y = newLeaves[leafCounter].y
							// 	leafCounter++
							// 	return l
							// }))
							.join(
								enter => enter.append("circle")
									.style("fill", d => {
										if (d.data.geo_scope === 'Unknown') {
											return "#ff254a"
										} else if (d.data.geo_scope === 'Level 1') {
											return "white"
										} else if (d.data.geo_scope === 'Level 2') {
											return "#ff7a91"
										} else if (d.data.geo_scope === 'Level 3') {
											return "#bf1b32"
										}
									})
									.style("stroke", d => {
										if (d.data.geo_scope === 'Unknown') {
											return "white"
										} else if (d.data.geo_scope === 'Level 1') {
											return "white"
										} else if (d.data.geo_scope === 'Level 2') {
											return "#ff7a91"
										} else if (d.data.geo_scope === 'Level 3') {
											return "#bf1b32"
										}
									})
									// .style("fill", (d,i) => `rgb(255, 255, ${i})`)
									.attr("class", "leaf-circle")
									.attr("cx", d => d.x)
									.attr("cy", d => d.y)
									.attr("r", d => d.r)
									.attr("opacity", 0)
								.call(enter => enter.transition(t)
									.attr("opacity", 1)
								),
								update => update
									.call(update => update.transition(t)
										.attr("cx", d => d.x)
										.attr("cy", d => d.y)
										.attr("r", d => d.r)
								),
								exit => exit
									.call(exit => exit.transition(t/2)
										.attr("r", 1e-6)
                    .remove()
									)
							)

							const leafCirclesRollover = lg.selectAll(".leaf-circle-rollover")
							.data(node.leaves(), d =>  d.data.access_now_ID)
							.join(
								enter => enter.append("circle")
									.style("fill", "white")
									.style("stroke", "black")
									.style("stroke-width", "2px")
									.attr("fill-opacity", 0)
									.attr("stroke-opacity", 0)
									.attr("class", "leaf-circle-rollover")
									.attr("cx", d => d.x)
									.attr("cy", d => d.y)
									.attr("r", 1e-6)
								.call(enter => enter.transition(t)
									.attr("r", d => d.r)
								),
								update => update
									.call(update => update.transition(t)
										.attr("cx", d => d.x)
										.attr("cy", d => d.y)
										.attr("r", d => d.r)
								),
								exit => exit
									.call(exit => exit.transition(t/2)
										.attr("r", 1e-6)
                    .remove()
									)
							)

							d3.selectAll(".leaf-circle-rollover")
								.on('mousemove', function(d) {
									// console.log('mousemove', d3.select(this))
									div
										.transition()
										.duration(200)
										.style('opacity', 1);
									div
										.html(makeTooltipInfo(d))
										.style('left', d3.event.pageX + 14 + 'px')
										.style('top', d3.event.pageY - 78 + 'px');
									d3.select(this).style("cursor", "pointer");
									d3.select(this).attr("stroke-opacity", 1)
								})
								.on('mouseout', function() {
									d3.select(this).attr("stroke-opacity", 0)
									div
										.transition()
										.duration(500)
										.style('opacity', 0);
							})

						g.selectAll("text")
							.data(node.ancestors()[0].children, d => d.data.name)
							.join(
								enter => enter.append("text")
										// .enter().append("tspan")
										.attr("fill", "black")
										.attr("class", "group-label")
										.attr("text-anchor", "middle")
										.attr("x", d => d.x + 1)
										.attr("y", d => d.y + 1)
										.attr("dy", -1)//set the dy here
										// .attr("y", (d, i) => {
										// 	return	d.y + (i - getLabelLines(getLabelWords(d.data.name), d.data.name).length / 2 + 0.8) * lineHeight
										// })
										// .attr("transform", d => `translate(${d.x + 1},${d.y + d.r + 1})`)
										.attr("opacity", 0)
										.text(d => d.data.name)
										// .call(wrap, d => 30)
									.call(enter => enter.transition(t)
										.attr("opacity", d => d.data.name === "undefined" ? 0 : 1)).call(wrap, 30),
								update => update
										.attr("fill", "black")
										// .attr("y", 0)
										// .attr("transform", d => `translate(${d.x + 1},${d.y + d.r + 1})`)
										.attr("x", d => d.x + 1)
										.attr("y", d => d.y + 1)
										.attr("dy", -1)//set the dy here
										.attr("opacity", 0)
									.call(update => update.transition(t)
										// .attr("x", (d, i) => i * 16)),
										.attr("opacity", d => d.data.name === "undefined" ? 0 : 1)).call(wrap, 30),
								exit => exit
										.attr("fill", "brown")
									.call(exit => exit.transition(t/2)
										// .attr("y", 30)
										.attr("opacity", 0)
										.remove())
						);
						g.selectAll(".group-label text")
							.call(wrap, d => d.r)
						}

				// Make tooltip html
				function makeTooltipInfo(d) {
					let html = '';
					if (d.data.duration_affected_days) {
						html += '<b>Affected Days</b> ' + d.data.duration_affected_days
					}
					if (d.data.shutdown_status) {
						html += '<br><b>Shutdown Status</b> ' + d.data.shutdown_status
					}
					if (d.data.ordered_by) {
						html += '<br><b>Ordered By</b> ' + d.data.ordered_by
					}
					if (d.data.actual_cause) {
						html += '<br><b>Actual Cause</b> ' + d.data.actual_cause
					}
					if (d.data.official_just) {
						html += '<br><b>Official Justification</b> ' + d.data.official_just
					}
					if (d.data.country) {
						html += '<br><b>Country</b> ' + d.data.country
					}
					if (d.data.shutdown_type_new) {
						html += '<br><b>Shutdown Type</b> ' + d.data.shutdown_type_new
					}
					if (d.data.affected_network) {
						html += '<br><b>Affected Network</b> ' + d.data.affected_network
					}
					if (d.data['full or service-based']) {
						html += '<br><b>Full or Service-based</b> ' + d.data['full or service-based']
					}
					if (d.data.geo_scope_label) {
						html += '<br><b>Geographic Scope</b> ' + d.data.geo_scope_label
					}
					if (d.data.access_now_ID) {
						html += '<br><b>ID</b> ' + d.data.access_now_ID
					}
					// console.log(html.toString())
					return `${html.toString()}`
				}

        function updateNodeGroups(data, byVar) {
            const categoryArrayObj = data.reduce((obj, d, i) => {
                // here we want to group elements according to the values they
                // have in common for a particular key (that we select by the button)
                // console.log(d[byVar])
                if (obj[d[byVar]]){
                    obj[d[byVar]].push(d);
                } else {
                    obj[d[byVar]] = [d];
                }
                return obj
                // console.log(d[byVar])
            }, {})

            // console.log(categoryArrayObj)

            const hierarchy_group_nodes = []
            for (const property in categoryArrayObj) {
                const newObj = {}
                newObj['name'] = property
								newObj['padding'] = 0
                newObj['children'] = categoryArrayObj[property]
                hierarchy_group_nodes.push(newObj)
            }
            // console.log(hierarchy_group_nodes)

						//create a sub hierarchy for sub regions
						region_hierarchy_group_nodes = hierarchy_group_nodes.map( el => {
							// get the children for each category
							// and create subcategories for subregions							
							let newRegionObj = {}
							// for (let i = 0; i < subRegionKeys.length; i++) {
								newRegionObj = el.children.reduce((obj, d) => {
									if (obj[d['geo_scope_label']]){
											obj[d['geo_scope_label']].push(d);
									} else {
											obj[d['geo_scope_label']] = [d];
									}
									return obj
								}, {})
							// }
							// console.log(el.name, newRegionObj)

							// transform key/value pairs
							const transfRegionArray = []
							for (const property in newRegionObj) {
                const newObj = {}
                newObj['name'] = property
								newObj['padding'] = 15
                newObj['children'] = newRegionObj[property]
                transfRegionArray.push(newObj)
            	}

							// console.log(transfRegionArray)

							nObj = {}
							nObj.name = el.name
							nObj.padding = -8
							nObj.children = transfRegionArray
							return nObj
						})

						// console.log(region_hierarchy_group_nodes)

            const updatedDataObj = {
                'name': 'root',
								'padding': 20,
                'children': region_hierarchy_group_nodes
								// 'children': hierarchy_group_nodes
            }
            console.log(updatedDataObj)
            return updatedDataObj
        }

				function updateCallout(byVar) {
					document.getElementById("callout").innerHTML = calloutMap[byVar]
				}

				function updateButtons() {
					// Toggle the bubble chart based on
					// the currently clicked button.
					updateNodeGroups(formatted, buttonId)
					updateCallout(buttonId)
					// root = d3.hierarchy(makeData())
					//     .sum(d => d.value)
					//     .sort((a, b) => a.value - b.value);
					root = d3.hierarchy(updateNodeGroups(formatted, buttonId))
							.sum(d => d.radius)
							.sort((a,b) => a.data.geo_scope_val - b.data.geo_scope_val)
					draw(false, root, buttonId);
				}

        ////// UI ELEMENTS ////////
        function setupButtons() {
					// set the "all group" to be selected by default
					document.getElementById(`${buttonId}`).classList.add("selected")
					d3.select('#leftArrow')
						.on('click', function() {
							selectedIndex--
							if (selectedIndex < 0) {
								selectedIndex = 0
							}
							buttonId = selectedButtonIds[selectedIndex]
							const selector = `${buttonId}`
							console.log(selector)
							if (selector !== 'undefined') {
								d3.selectAll('.button').classed('selected', false)
								document.getElementById(selector).classList.add("selected")
								console.log(buttonId, selectedIndex)
								updateButtons()
							}
					})

					d3.select('#rightArrow')
						.on('click', function() {
							selectedIndex++
							if (selectedIndex > selectedButtonIds.length) {
								selectedIndex = selectedButtonIds.length - 1
							}
							buttonId = selectedButtonIds[selectedIndex]
							const selector = `${buttonId}`
							console.log(selector)
							if (selector !== 'undefined') {
								d3.selectAll('.button').classed('selected', false)
								document.getElementById(selector).classList.add("selected")
								console.log(buttonId, selectedIndex)
								updateButtons()
							}
					})

					d3.selectAll('.button')
						.on('click', function() {
							// Remove active class from all buttons
							// d3.selectAll('.button').classed('active', false)
							d3.selectAll('.button').classed('selected', false)
							// Find the button just clicked
							var button = d3.select(this)
							button.classed('selected', true)
							// Set it as the active button
							// button.classed('active', true)
							// button.classed('focus', true)
							// button.classed('selected', true)

							// Get the id of the button
							buttonId = button.attr('id')

							//Get selected Index
							for (let i = 0; i < selectedButtonIds.length; i++) {
								if (buttonId === selectedButtonIds[i]) {
									selectedIndex = i
								}
							}

							console.log(buttonId, selectedIndex)
							updateButtons()
						})
						
        }
        
        setupButtons()
				updateCallout("all")
    
    })


      ////// UTILS ////////
      function randBetween(min, max){
        return Math.floor(Math.random() * (max - min + 1) + min);
      }

			function wrap(text, width) {
				text.each(function() {
					var text = d3.select(this),
							words = text.text().split(/\s+/).reverse(),
							word,
							line = [],
							lineNumber = 0,
							lineHeight = 1.1, // ems
							y = text.attr("y"),
							x = text.attr("x")
							dy = parseFloat(text.attr("dy")),
							tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
					// console.log(x, y, dy)
					while (word = words.pop()) {
						line.push(word);
						tspan.text(line.join(" "));
						if (tspan.node().getComputedTextLength() > width) {
							line.pop();
							tspan.text(line.join(" "));
							line = [word];
							tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
						}
					}
				});
			}

			function getLabelWords(text) {
				const words = text.split(/\s+/g); // To hyphenate: /\s+|(?<=-)/
				if (!words[words.length - 1]) words.pop();
				if (!words[0]) words.shift();
				return words;
			}

			function measureWidth(text) {
				const context = document.createElement("canvas").getContext("2d");
				return text => context.measureText(text).width;
			}

			function getTargetWidth(text) {
				return  Math.sqrt(measureWidth(text.trim()) * lineHeight)
			}

			
			function getLabelLines(words, text) {
				let line;
				let lineWidth0 = Infinity;
				const lines = [];
				for (let i = 0, n = words.length; i < n; ++i) {
					let lineText1 = (line ? line.text + " " : "") + words[i];
					let lineWidth1 = measureWidth(lineText1);
					if ((lineWidth0 + lineWidth1) / 2 < getTargetWidth(text)) {
						line.width = lineWidth0 = lineWidth1;
						line.text = lineText1;
					} else {
						lineWidth0 = measureWidth(words[i]);
						line = {width: lineWidth0, text: words[i]};
						lines.push(line);
					}
				}
				return lines;
			}

			function getTextRadius(lines) {
				let radius = 0;
				for (let i = 0, n = lines.length; i < n; ++i) {
					const dy = (Math.abs(i - n / 2 + 0.5) + 0.5) * lineHeight;
					const dx = lines[i].width / 2;
					radius = Math.max(radius, Math.sqrt(dx ** 2 + dy ** 2));
				}
				return radius;
			}

    </script>
  </body>
</html>